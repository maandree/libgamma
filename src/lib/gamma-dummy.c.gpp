/* -*- c -*- */
/* See LICENSE file for copyright and license details. */
#ifndef HAVE_LIBGAMMA_METHOD_DUMMY
# error Compiling gamma-dummy.c without HAVE_LIBGAMMA_METHOD_DUMMY
#endif

#include "gamma-dummy.h"

#include "libgamma-error.h"
#include "libgamma-method.h"
#include "libgamma-facade.h"
#include "edid.h"
#include "gamma-helper.h"

#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>



/**
 * Configuration set for the dummy adjustment method
 */
typedef struct libgamma_dummy_configurations {
	/**
	 * The method's capabilities
	 * 
	 * Some fields are ignored:
	 * - real
	 * - fake
	 */
	libgamma_method_capabilities_t capabilities;

	/**
	 * Template for CRTC:s information
	 * 
	 * Some fields are ignored:
	 * - width_mm_edid
	 * - width_mm_edid_error
	 * - height_mm_edid
	 * - height_mm_edid_error
	 * - gamma_red
	 * - gamma_green
	 * - gamma_blue
	 * - gamma_error
	 */
	libgamma_crtc_information_t crtc_info_template;

	/**
	 * The adjustment method to use
	 */
	int real_method;

	/**
	 * The number of sites on the system
	 */
	size_t site_count;

	/**
	 * The number of paritions on a site before it has been configured
	 */
	size_t default_partition_count;

	/**
	 * The number of CRTC:s on a paritions before it has been configured
	 */
	size_t default_crtc_count;

	/**
	 * Whether the sites should be inherited from the real method
	 */
	unsigned inherit_sites : 1;

	/**
	 * Whether the partitions should be inherited from the real method
	 */
	unsigned inherit_partition_count : 1;

	/**
	 * Whether the CRTC:s should be inherited from the real method
	 */
	unsigned inherit_crtc_count : 1;

	/**
	 * When a site has been created, stall until the partition count has
	 * been configured
	 */
	unsigned stall_for_partition_count : 1;

	/**
	 * When a parition has been created, stall until the CRTC count has
	 * been configured
	 */
	unsigned stall_for_crtc_count : 1;

	/**
	 * Methods should stall until the system has been configured
	 * unless $LIBGAMMA_DUMMY_STALL is not true
	 */
	unsigned stalled_start : 1;

	/**
	 * Whether to print what is going on in the phony system
	 */
	unsigned verbose : 1;

} libgamma_dummy_configurations_t;


/**
 * Dummy adjustment method internal data for a CRTC
 */
typedef struct libgamma_dummy_crtc {
	/**
	 * The gamma ramp for the red channel
	 */
	void *restrict gamma_red;

	/**
	 * The gamma ramp for the green channel
	 */
	void *restrict gamma_green;

	/**
	 * The gamma ramp for the blue channel
	 */
	void *restrict gamma_blue;

	/**
	 * Information about the CRTC and monitor
	 * 
	 * Some fields are ignored:
	 * - width_mm_edid
	 * - width_mm_edid_error
	 * - height_mm_edid
	 * - height_mm_edid_error
	 * - gamma_red
	 * - gamma_green
	 * - gamma_blue
	 * - gamma_error
	 */
	libgamma_crtc_information_t info;

	/**
	 * Partition state that contains this information
	 */
	libgamma_crtc_state_t *state;

} libgamma_dummy_crtc_t;


/**
 * Dummy adjustment method internal data for a partition
 */
typedef struct libgamma_dummy_partition {
	/**
	 * The CRTC:s on the system
	 */
	libgamma_dummy_crtc_t *crtcs;

	/**
	 * The number of CRTC:s on the system
	 */
	size_t crtc_count;

	/**
	 * Partition state that contains this information
	 */
	libgamma_partition_state_t *state;

} libgamma_dummy_partition_t;


/**
 * Dummy adjustment method internal data for a site
 */
typedef struct libgamma_dummy_site {
	/**
	 * The partitions on the system
	 */
	libgamma_dummy_partition_t *partitions;

	/**
	 * The number of partitions on the system
	 */
	size_t partition_count;

	/**
	 * Site state that contains this information
	 */
	libgamma_site_state_t *state;

} libgamma_dummy_site_t;



/**
 * Restore the gamma ramps for a CRTC to the system settings for that CRTC
 * and ignore the method's capabilities
 * 
 * @param   this  The CRTC data
 * @return        Zero on success, otherwise (negative) the value of an
 *                error identifier provided by this library
 */
static int libgamma_dummy_crtc_restore_forced(libgamma_dummy_crtc_t *restrict data);



/**
 * Configurations for the dummy adjustment method.
 */
static libgamma_dummy_configurations_t libgamma_dummy_configurations = {
	.capabilities = {
		.crtc_information = (1 << LIBGAMMA_CRTC_INFO_COUNT) - 1,
		.default_site_known = 1,
		.multiple_sites = 1,
		.multiple_partitions = 1,
		.multiple_crtcs = 1,
		.partitions_are_graphics_cards = 1,
		.site_restore = 1,
		.partition_restore = 1,
		.crtc_restore = 1,
		.identical_gamma_sizes = 0,
		.fixed_gamma_size = 0,
		.fixed_gamma_depth = 0
	},
	.crtc_info_template = {
		.edid = NULL,
		.edid_length = 0,
		.edid_error = LIBGAMMA_EDID_NOT_FOUND,
		.width_mm = 400,
		.width_mm_error = 0,
		.height_mm = 300,
		.height_mm_error = 0,
		.red_gamma_size = 1024,
		.green_gamma_size = 2048,
		.blue_gamma_size = 512,
		.gamma_size_error = 0,
		.gamma_depth = 64,
		.gamma_depth_error = 0,
		.gamma_support = 1,
		.gamma_support_error = 0,
		.subpixel_order = LIBGAMMA_SUBPIXEL_ORDER_HORIZONTAL_RGB,
		.subpixel_order_error = 0,
		.active = 1,
		.active_error = 0,
		.connector_name = NULL,
		.connector_name_error = LIBGAMMA_CONNECTOR_TYPE_NOT_RECOGNISED,
		.connector_type = LIBGAMMA_CONNECTOR_TYPE_Unknown,
		.connector_type_error = 0
	},
	.real_method = LIBGAMMA_METHOD_DUMMY,
	.site_count = 2,
	.default_partition_count = 2,
	.default_crtc_count = 2,
	.inherit_sites = 1,
	.inherit_partition_count = 1,
	.inherit_crtc_count = 1,
	.stall_for_partition_count = 0,
	.stall_for_crtc_count = 0,
	.stalled_start = 1,
	.verbose = 0
};



/**
 * Return the capabilities of the adjustment method
 * 
 * @param  this  The data structure to fill with the method's capabilities
 */
void
libgamma_dummy_method_capabilities(libgamma_method_capabilities_t *restrict this)
{
	int real_method = libgamma_dummy_configurations.real_method;
	*this = libgamma_dummy_configurations.capabilities;
	this->real = real_method != LIBGAMMA_METHOD_DUMMY;
	this->fake = this->real;
	this->auto_restore = real_method == LIBGAMMA_METHOD_QUARTZ_CORE_GRAPHICS;
}


/**
 * Initialise an allocated site state
 * 
 * @param   this    The site state to initialise
 * @param   site    The site identifier, unless it is `NULL` it must a
 *                  `free`:able. Once the state is destroyed the library
 *                  will attempt to free it. There you should not free
 *                  it yourself, and it must not be a string constant
 *                  or allocate on the stack. Note however that it will
 *                  not be free:d if this function fails.
 * @return          Zero on success, otherwise (negative) the value of an
 *                  error identifier provided by this library
 */
int
libgamma_dummy_site_initialise(libgamma_site_state_t *restrict this, char *restrict site)
{
	libgamma_dummy_site_t *data = NULL;
	size_t i, sites, crtcs;

	sites = libgamma_dummy_configurations.site_count;
	if (!libgamma_dummy_configurations.capabilities.multiple_sites)
		sites = !!sites;
	this->data = NULL;

	if (site && *site && (atoll(site) < 0 || sites <= (unsigned long long)atoll(site)))
		return LIBGAMMA_NO_SUCH_SITE;

	data = malloc(sizeof(libgamma_dummy_site_t));
	if (!data)
		goto fail;

	this->data = data;
	data->state = this;

	data->partition_count = libgamma_dummy_configurations.default_partition_count;
	if (!libgamma_dummy_configurations.capabilities.multiple_partitions)
		data->partition_count = !!data->partition_count;

	crtcs = libgamma_dummy_configurations.default_crtc_count;
	if (!libgamma_dummy_configurations.capabilities.multiple_crtcs)
		crtcs = !!crtcs;

	data->partitions = malloc(data->partition_count * sizeof(libgamma_dummy_partition_t));
	if (!data->partitions)
		goto fail;

	for (i = 0; i < data->partition_count; i++)
		data->partitions[i].crtc_count = crtcs;

	this->partitions_available = data->partition_count;

	return 0;

fail:
	free(data);
	this->data = NULL;
	return LIBGAMMA_ERRNO_SET;
}


/**
 * Release all resources held by a site state
 * 
 * @param  this  The site state
 */
void
libgamma_dummy_site_destroy(libgamma_site_state_t *restrict this)
{
	libgamma_dummy_site_t *data = this->data;
	if (!data)
		return;

	free(data->partitions);
	free(data);
}


/**
 * Restore the gamma ramps all CRTC:s with a site to the system settings
 * 
 * @param   this  The site state
 * @return        Zero on success, otherwise (negative) the value of an
 *                error identifier provided by this library
 */
int
libgamma_dummy_site_restore(libgamma_site_state_t *restrict this)
{
	libgamma_dummy_site_t *data = this->data;
	size_t i, j;

	if (!libgamma_dummy_configurations.capabilities.site_restore) {
		errno = ENOTSUP;
		return LIBGAMMA_ERRNO_SET;
	}

	for (j = 0; j < data->partition_count; j++)
		for (i = 0; i < data->partitions[j].crtc_count; i++)
			if (libgamma_dummy_crtc_restore_forced(data->partitions[j].crtcs + i) < 0)
				return -1;

	return 0;
}



/**
 * Initialise an allocated partition state
 * 
 * @param   this       The partition state to initialise
 * @param   site       The site state for the site that the partition belongs to
 * @param   partition  The the index of the partition within the site
 * @return             Zero on success, otherwise (negative) the value of an
 *                     error identifier provided by this library
 */
int
libgamma_dummy_partition_initialise(libgamma_partition_state_t *restrict this,
                                    libgamma_site_state_t *restrict site, size_t partition)
{
	libgamma_crtc_information_t template = libgamma_dummy_configurations.crtc_info_template;
	libgamma_dummy_site_t *site_data = site->data;
	libgamma_dummy_partition_t *data = &site_data->partitions[partition];
	libgamma_dummy_crtc_t *crtc_data;
	size_t i, n;

	this->data = NULL;

	if (partition >= site_data->partition_count)
		return LIBGAMMA_NO_SUCH_PARTITION;

	this->data = data;
	data->state = this;

	data->crtcs = calloc(data->crtc_count, sizeof(libgamma_dummy_crtc_t));
	if (!data->crtcs)
		goto fail;
	for (i = 0; i < data->crtc_count; i++) {
		crtc_data = data->crtcs + i;
		crtc_data->info = template;

		/* Duplicate strings */
		if (crtc_data->info.edid) {
			crtc_data->info.edid = malloc(crtc_data->info.edid_length * sizeof(char));
			if (!crtc_data->info.edid)
				goto fail;
			memcpy(crtc_data->info.edid, template.edid, crtc_data->info.edid_length * sizeof(char));
		}
		if (crtc_data->info.connector_name) {
			n = strlen(crtc_data->info.connector_name);
			crtc_data->info.connector_name = malloc((n + 1) * sizeof(char));
			if (crtc_data->info.connector_name == NULL)
				goto fail;
			memcpy(crtc_data->info.connector_name, template.connector_name, (n + 1) * sizeof(char));
		}
	}

	this->crtcs_available = data->crtc_count;

	return 0;

fail:
	for (i = 0; i < data->crtc_count; i++) {
		free(data->crtcs[i].info.edid);
		free(data->crtcs[i].info.connector_name);
	}
	free(data->crtcs);
	data->crtcs = NULL;
	return LIBGAMMA_ERRNO_SET;
}


/**
 * Release all resources held by a partition state
 * 
 * @param  this  The partition state
 */
void
libgamma_dummy_partition_destroy(libgamma_partition_state_t *restrict this)
{
	libgamma_dummy_partition_t *data = this->data;
	size_t i;

	if (data) {
		for (i = 0; i < data->crtc_count; i++) {
			free(data->crtcs[i].info.edid);
			free(data->crtcs[i].info.connector_name);
		}
		free(data->crtcs);
		data->crtcs = NULL;
	}
}


/**
 * Restore the gamma ramps all CRTC:s with a partition to the system settings
 * 
 * @param   this  The partition state
 * @return        Zero on success, otherwise (negative) the value of an
 *                error identifier provided by this library
 */
int
libgamma_dummy_partition_restore(libgamma_partition_state_t *restrict this)
{
	libgamma_dummy_partition_t *data = this->data;
	size_t i;

	if (!libgamma_dummy_configurations.capabilities.partition_restore) {
		errno = ENOTSUP;
		return LIBGAMMA_ERRNO_SET;
	}

	for (i = 0; i < data->crtc_count; i++)
		if (libgamma_dummy_crtc_restore_forced(data->crtcs + i) < 0)
			return -1;

	return 0;
}



/**
 * Initialise an allocated CRTC state
 * 
 * @param   this       The CRTC state to initialise
 * @param   partition  The partition state for the partition that the CRTC belongs to
 * @param   crtc       The the index of the CRTC within the site
 * @return             Zero on success, otherwise (negative) the value of an
 *                     error identifier provided by this library
 */
int
libgamma_dummy_crtc_initialise(libgamma_crtc_state_t *restrict this,
                               libgamma_partition_state_t *restrict partition, size_t crtc)
{
	libgamma_dummy_partition_t *partition_data = partition->data;
	libgamma_dummy_crtc_t *data = &partition_data->crtcs[crtc];
	size_t stop_size;

	this->data = NULL;

	if (crtc >= partition_data->crtc_count)
		return LIBGAMMA_NO_SUCH_CRTC;

	this->data = data;
	data->state = this;

	if (data->info.gamma_depth == -1)
		stop_size = sizeof(float);
	else if (data->info.gamma_depth == -2)
		stop_size = sizeof(double);
	else
		stop_size = (size_t)data->info.gamma_depth / 8;

	data->gamma_red = malloc(data->info.red_gamma_size * stop_size);
	if (!data->gamma_red)
		goto fail;
	data->gamma_green = malloc(data->info.green_gamma_size * stop_size);
	if (!data->gamma_green)
		goto fail;
	data->gamma_blue = malloc(data->info.blue_gamma_size * stop_size);
	if (!data->gamma_blue)
		goto fail;

	return libgamma_dummy_crtc_restore_forced(data);

fail:
	free(data->gamma_red),   data->gamma_red   = NULL;
	free(data->gamma_green), data->gamma_green = NULL;
	free(data->gamma_blue),  data->gamma_blue  = NULL;
	return LIBGAMMA_ERRNO_SET;
}


/**
 * Release all resources held by a CRTC state
 * 
 * @param  this  The CRTC state
 */
void
libgamma_dummy_crtc_destroy(libgamma_crtc_state_t *restrict this)
{
	libgamma_dummy_crtc_t *data = this->data;
	if (data) {
		free(data->gamma_red),   data->gamma_red   = NULL;
		free(data->gamma_green), data->gamma_green = NULL;
		free(data->gamma_blue),  data->gamma_blue  = NULL;
	}
}


/**
 * Restore the gamma ramps for a CRTC to the system settings for that CRTC
 * 
 * @param   this  The CRTC state
 * @return        Zero on success, otherwise (negative) the value of an
 *                error identifier provided by this library
 */
int
libgamma_dummy_crtc_restore(libgamma_crtc_state_t *restrict this)
{
	if (!libgamma_dummy_configurations.capabilities.crtc_restore) {
		errno = ENOTSUP;
		return LIBGAMMA_ERRNO_SET;
	}
	return libgamma_dummy_crtc_restore_forced(this->data);
}


/**
 * Restore the gamma ramps for a CRTC to the system settings for that CRTC
 * and ignore the method's capabilities
 * 
 * @param   this  The CRTC data
 * @return        Zero on success, otherwise (negative) the value of an
 *                error identifier provided by this library
 */
static int
libgamma_dummy_crtc_restore_forced(libgamma_dummy_crtc_t *restrict data)
{
	size_t rn = data->info.  red_gamma_size;
	size_t gn = data->info.green_gamma_size;
	size_t bn = data->info. blue_gamma_size;
	size_t i;

	if (!data->gamma_red)
		return 0;

#define __reset_ramps(TYPE, MAX)\
	do {\
		TYPE *red   = data->gamma_red;\
		TYPE *green = data->gamma_green;\
		TYPE *blue  = data->gamma_blue;\
		for (i = 0; i < rn; i++) red  [i] = (TYPE)((double)(MAX) * ((double)i / (double)(rn - 1)));\
		for (i = 0; i < gn; i++) green[i] = (TYPE)((double)(MAX) * ((double)i / (double)(gn - 1)));\
		for (i = 0; i < bn; i++) blue [i] = (TYPE)((double)(MAX) * ((double)i / (double)(bn - 1)));\
	} while (0)

	if      (data->info.gamma_depth ==  8) __reset_ramps(uint8_t,  INT8_MAX);
	else if (data->info.gamma_depth == 16) __reset_ramps(uint16_t, INT16_MAX);
	else if (data->info.gamma_depth == 32) __reset_ramps(uint32_t, INT32_MAX);
	else if (data->info.gamma_depth == 64) __reset_ramps(uint64_t, INT64_MAX);
	else if (data->info.gamma_depth == -1) __reset_ramps(float,    1);
	else                                   __reset_ramps(double,   1);

#undef __reset_ramps

	return 0;
}



/**
 * Read information about a CRTC
 * 
 * @param   this    Instance of a data structure to fill with the information about the CRTC
 * @param   crtc    The state of the CRTC whose information should be read
 * @param   fields  OR:ed identifiers for the information about the CRTC that should be read
 * @return          Zero on success, -1 on error. On error refer to the error reports in `this`
 */
int
libgamma_dummy_get_crtc_information(libgamma_crtc_information_t *restrict this,
                                    libgamma_crtc_state_t *restrict crtc, int32_t fields)
{
	libgamma_dummy_crtc_t *restrict data = crtc->data;
	int supported = libgamma_dummy_configurations.capabilities.crtc_information;
	int e = 0;
	size_t n;

	/* Copy over information */
	*this = data->info;

	/* Duplicate strings */
	if (this->edid) {
		this->edid = malloc(this->edid_length * sizeof(char));
		if (!this->edid)
			this->edid_error = errno;
		memcpy(this->edid, data->info.edid, this->edid_length * sizeof(char));
	}
	if (this->connector_name) {
		n = strlen(this->connector_name);
		this->connector_name = malloc((n + 1) * sizeof(char));
		if (!this->connector_name)
			this->connector_name_error = errno;
		memcpy(this->connector_name, data->info.connector_name, (n + 1) * sizeof(char));
	}

	/* Parse EDID */
	if (this->edid_error)
		this->width_mm_edid_error = this->height_mm_edid_error = this->gamma_error = this->edid_error;
	else if (fields & (LIBGAMMA_CRTC_INFO_MACRO_EDID ^ LIBGAMMA_CRTC_INFO_EDID))
		e |= libgamma_parse_edid(this, fields);

	/* Test errors */
#define _E(FIELD, VAR)\
	((fields & FIELD) ? ((supported & FIELD) ? VAR : (VAR = LIBGAMMA_CRTC_INFO_NOT_SUPPORTED)) : 0)
	e |= _E(LIBGAMMA_CRTC_INFO_EDID,           this->edid_error);
	e |= _E(LIBGAMMA_CRTC_INFO_WIDTH_MM,       this->width_mm_error);
	e |= _E(LIBGAMMA_CRTC_INFO_HEIGHT_MM,      this->height_mm_error);
	e |= _E(LIBGAMMA_CRTC_INFO_GAMMA_SIZE,     this->gamma_size_error);
	e |= _E(LIBGAMMA_CRTC_INFO_GAMMA_DEPTH,    this->gamma_depth_error);
	e |= _E(LIBGAMMA_CRTC_INFO_GAMMA_SUPPORT,  this->gamma_support_error);
	e |= _E(LIBGAMMA_CRTC_INFO_SUBPIXEL_ORDER, this->subpixel_order_error);
	e |= _E(LIBGAMMA_CRTC_INFO_ACTIVE,         this->active_error);
	e |= _E(LIBGAMMA_CRTC_INFO_CONNECTOR_NAME, this->connector_name_error);
	e |= _E(LIBGAMMA_CRTC_INFO_CONNECTOR_TYPE, this->connector_type_error);

	if ((fields & LIBGAMMA_CRTC_INFO_WIDTH_MM_EDID) && !(supported & LIBGAMMA_CRTC_INFO_WIDTH_MM_EDID))
		e |= this->width_mm_edid_error = LIBGAMMA_CRTC_INFO_NOT_SUPPORTED;
	if ((fields & LIBGAMMA_CRTC_INFO_HEIGHT_MM_EDID) && !(supported & LIBGAMMA_CRTC_INFO_HEIGHT_MM_EDID))
		e |= this->height_mm_edid_error = LIBGAMMA_CRTC_INFO_NOT_SUPPORTED;
	if ((fields & LIBGAMMA_CRTC_INFO_GAMMA) && !(supported & LIBGAMMA_CRTC_INFO_GAMMA))
		e |= this->gamma_error = LIBGAMMA_CRTC_INFO_NOT_SUPPORTED;
#undef _E

	return e ? -1 : 0;
}


/**
 * Get the current gamma ramps for a CRTC
 * 
 * @param   1      The data type for the ramp stop elements
 * @param   2      The `ramp*` pattern for the ramp structure and function to call.
 * @param   3      Either of `bit8`, `bit16`, `bit32`, `bit64`, `float_single`, `float_double`;
 *                 rather self-explanatory
 * @param   4      The number of bits in the gamma depth, -1 for single precision float,
 *                 (`float`) and -2 for double percition float (`double`)
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to fill with the current values
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_get_gamma_ramps ()
$>{
int
libgamma_dummy_crtc_get_gamma_${2}(libgamma_crtc_state_t *restrict this, libgamma_gamma_${2}_t *restrict ramps)
{
	libgamma_dummy_crtc_t *data = this->data;
	libgamma_gamma_ramps_any_t ramps_;
	${1}* r_ramp = data->gamma_red;
	${1}* g_ramp = data->gamma_green;
	${1}* b_ramp = data->gamma_blue;
	size_t rn = data->info.red_gamma_size;
	size_t gn = data->info.green_gamma_size;
	size_t bn = data->info.blue_gamma_size;
	size_t i;

#ifdef DEBUG
	/* Check gamma ramp sizes */
	if (libgamma_dummy_configurations.capabilities.identical_gamma_sizes)
		if (ramps->red_size != ramps->green_size || ramps->red_size != ramps->blue_size)
			return LIBGAMMA_MIXED_GAMMA_RAMP_SIZE;
	if (ramps->red_size != rn || ramps->green_size != gn || ramps->blue_size != bn)
		return LIBGAMMA_WRONG_GAMMA_RAMP_SIZE;
#endif

	if (!data->info.gamma_support)
		return LIBGAMMA_GAMMA_RAMP_READ_FAILED;

#define __trans(DEPTH, SUFFIX)\
	do {\
		if (data->info.gamma_depth == DEPTH) {\
			ramps_.${3} = *ramps;\
			return libgamma_translated_ramp_get(this, &ramps_, ${4}, DEPTH, libgamma_crtc_get_gamma_ramps ## SUFFIX);\
		}\
	} while (0)

$>if [ ! ${4} = 8 ]; then
	__trans(8, 8);
$>fi
$>if [ ! ${4} = 16 ]; then
	__trans(16, 16);
$>fi
$>if [ ! ${4} = 32 ]; then
	__trans(32, 32);
$>fi
$>if [ ! ${4} = 64 ]; then
	__trans(64, 64);
$>fi
$>if [ ! ${4} = -1 ]; then
	__trans(-1, f);
$>fi
$>if [ ! ${4} = -2 ]; then
	__trans(-2, d);
$>fi

#undef __trans

	for (i = 0; i < rn; i++) ramps->red[i]   = r_ramp[i];
	for (i = 0; i < gn; i++) ramps->green[i] = g_ramp[i];
	for (i = 0; i < bn; i++) ramps->blue[i]  = b_ramp[i];

	return 0;
}
$>}


/**
 * Set the gamma ramps for a CRTC
 * 
 * @param   1      The data type for the ramp stop elements
 * @param   2      The `ramp*` pattern for the ramp structure and function to call.
 * @param   3      Either of `bit8`, `bit16`, `bit32`, `bit64`, `float_single`, `float_double`;
 *                 rather self-explanatory
 * @param   4      The number of bits in the gamma depth, -1 for single precision float,
 *                 (`float`) and -2 for double percition float (`double`)
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to apply
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_set_gamma_ramps ()
$>{
int
libgamma_dummy_crtc_set_gamma_${2}(libgamma_crtc_state_t *restrict this, libgamma_gamma_${2}_t ramps)
{
	libgamma_dummy_crtc_t *data = this->data;
	libgamma_gamma_ramps_any_t ramps_;
	${1} *r_ramp = data->gamma_red;
	${1} *g_ramp = data->gamma_green;
	${1} *b_ramp = data->gamma_blue;
	size_t rn = data->info.red_gamma_size;
	size_t gn = data->info.green_gamma_size;
	size_t bn = data->info.blue_gamma_size;
	size_t i;

#ifdef DEBUG
	/* Check gamma ramp sizes */
	if (libgamma_dummy_configurations.capabilities.identical_gamma_sizes)
		if (ramps.red_size != ramps.green_size || ramps.red_size != ramps.blue_size)
			return LIBGAMMA_MIXED_GAMMA_RAMP_SIZE;
	if (ramps.red_size != rn || ramps.green_size != gn || ramps.blue_size != bn)
		return LIBGAMMA_WRONG_GAMMA_RAMP_SIZE;
#endif

	if (!data->info.gamma_support)
		return LIBGAMMA_GAMMA_RAMP_READ_FAILED;

#define __trans(DEPTH, SUFFIX)\
	do {\
		if (data->info.gamma_depth == DEPTH) {\
			ramps_.${3} = ramps;\
			return libgamma_translated_ramp_set(this, ramps_, ${4}, DEPTH, libgamma_crtc_set_gamma_ramps ## SUFFIX);\
		}\
	} while (0)

$>if [ ! ${4} = 8 ]; then
	__trans(8, 8);
$>fi
$>if [ ! ${4} = 16 ]; then
	__trans(16, 16);
$>fi
$>if [ ! ${4} = 32 ]; then
	__trans(32, 32);
$>fi
$>if [ ! ${4} = 64 ]; then
	__trans(64, 64);
$>fi
$>if [ ! ${4} = -1 ]; then
	__trans(-1, f);
$>fi
$>if [ ! ${4} = -2 ]; then
	__trans(-2, d);
$>fi

#undef __trans

	for (i = 0; i < rn; i++) r_ramp[i] = ramps.red[i];
	for (i = 0; i < gn; i++) g_ramp[i] = ramps.green[i];
	for (i = 0; i < bn; i++) b_ramp[i] = ramps.blue[i];

	return 0;
}
$>}



/**
 * Get the current gamma ramps for a CRTC, 8-bit gamma-depth version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to fill with the current values
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_get_gamma_ramps uint8_t ramps8 bits8 8


/**
 * Set the gamma ramps for a CRTC, 8-bit gamma-depth version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to apply
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_set_gamma_ramps uint8_t ramps8 bits8 8



/**
 * Get the current gamma ramps for a CRTC, 16-bit gamma-depth version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to fill with the current values
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_get_gamma_ramps uint16_t ramps16 bits16 16


/**
 * Set the gamma ramps for a CRTC, 16-bit gamma-depth version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to apply
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_set_gamma_ramps uint16_t ramps16 bits16 16



/**
 * Get the current gamma ramps for a CRTC, 32-bit gamma-depth version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to fill with the current values
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_get_gamma_ramps uint32_t ramps32 bits32 32


/**
 * Set the gamma ramps for a CRTC, 32-bit gamma-depth version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to apply
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_set_gamma_ramps uint32_t ramps32 bits32 32



/**
 * Get the current gamma ramps for a CRTC, 64-bit gamma-depth version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to fill with the current values
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_get_gamma_ramps uint64_t ramps64 bits64 64


/**
 * Set the gamma ramps for a CRTC, 64-bit gamma-depth version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to apply
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_set_gamma_ramps uint64_t ramps64 bits64 64



/**
 * Get the current gamma ramps for a CRTC, `float` version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to fill with the current values
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_get_gamma_ramps float rampsf float_single -1


/**
 * Set the gamma ramps for a CRTC, `float` version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to apply
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_set_gamma_ramps float rampsf float_single -1



/**
 * Get the current gamma ramps for a CRTC, `double` version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to fill with the current values
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_get_gamma_ramps double rampsd float_double -2


/**
 * Set the gamma ramps for a CRTC, `double` version
 * 
 * @param   this   The CRTC state
 * @param   ramps  The gamma ramps to apply
 * @return         Zero on success, otherwise (negative) the value of an
 *                 error identifier provided by this library
 */
$>libgamma_dummy_crtc_set_gamma_ramps double rampsd float_double -2
